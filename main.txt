# OpenManufacturing: Optical Packaging & Assembly Platform

## Project Overview

OpenManufacturing is a comprehensive software and hardware integration platform designed for advanced optical packaging automation in silicon photonics and quantum computing manufacturing. The system provides end-to-end solutions for fiber-to-chip alignment, optical packaging, BOM management, and high-throughput assembly with complete traceability and quality control.

![Optical Packaging Automation System Architecture](https://pub.mdpi-res.com/engproc/engproc-77-00019/article_deploy/html/images/engproc-77-00019-ag.png?1731902782)

## Repository Structure

```
openmanufacturing/
├── README.md
├── CONTRIBUTING.md
├── LICENSE
├── CHANGELOG.md
├── pyproject.toml           # Python package configuration using Poetry
├── requirements.txt         # For traditional pip installations
├── CMakeLists.txt           # For C++ components
├── Dockerfile               # Container definition
├── docker-compose.yml       # Multi-service deployment
├── .github/                 # CI/CD workflows
├── docs/                    # Documentation
│   ├── api/                 # API documentation 
│   ├── architecture/        # System architecture docs
│   ├── deployment/          # Deployment guides
│   ├── tutorials/           # User tutorials
│   └── manufacturing/       # Manufacturing process docs
├── src/                     # Source code
│   ├── core/                # Core Python modules
│   │   ├── __init__.py
│   │   ├── alignment/       # Fiber-to-chip alignment algorithms
│   │   ├── process/         # Process control and management
│   │   ├── inventory/       # BOM and inventory management
│   │   ├── vision/          # Machine vision modules
│   │   └── database/        # Data persistence layer
│   ├── cpp/                 # C++ components
│   │   ├── drivers/         # Hardware drivers
│   │   ├── alignment/       # Fast alignment algorithms
│   │   ├── control/         # Real-time control systems
│   │   └── visualization/   # Data visualization tools
│   ├── api/                 # REST API
│   │   ├── __init__.py
│   │   ├── routes/          # API endpoints
│   │   ├── models/          # Data models
│   │   └── middleware/      # API middleware
│   ├── ui/                  # Tauri v2 frontend
│   │   ├── src/             # TypeScript/React components
│   │   ├── public/          # Static assets
│   │   └── tauri.conf.json  # Tauri configuration
│   └── integrations/        # Third-party integrations
│       ├── __init__.py
│       ├── erp/             # ERP integrations
│       ├── plc/             # PLC interfaces
│       └── vision/          # Vision system integrations
├── scripts/                 # Utility scripts
│   ├── install.sh           # Installation script
│   ├── setup_environment.sh # Environment setup
│   └── calibration.py       # System calibration
└── tests/                   # Test suite
    ├── unit/                # Unit tests
    ├── integration/         # Integration tests
    ├── system/              # System tests
    └── fixtures/            # Test fixtures
```

## Core Components

### 1. Alignment Engine (`src/core/alignment`)

The Alignment Engine is responsible for precise fiber-to-chip alignment, which is critical for optical packaging.

```python
# src/core/alignment/alignment_engine.py
import numpy as np
from typing import Tuple, Dict, Optional
from dataclasses import dataclass
from ..vision.image_processing import detect_fiber_position, detect_chip_waveguide
from ..hardware.motion_controller import MotionController
from ..process.calibration import CalibrationProfile

@dataclass
class AlignmentParameters:
    """Parameters for fiber-to-chip alignment process"""
    position_tolerance_um: float = 0.1  # Microns
    angle_tolerance_deg: float = 0.05   # Degrees
    optical_power_threshold: float = -3.0  # dBm
    max_iterations: int = 100
    use_machine_learning: bool = True

class AlignmentEngine:
    """Core engine for fiber-to-chip alignment operations"""
    
    def __init__(
        self, 
        motion_controller: MotionController,
        calibration_profile: CalibrationProfile,
        parameters: Optional[AlignmentParameters] = None
    ):
        self.motion_controller = motion_controller
        self.calibration = calibration_profile
        self.parameters = parameters or AlignmentParameters()
        self.alignment_history = []
        self.is_aligned = False
        
    async def perform_coarse_alignment(self) -> Tuple[bool, Dict]:
        """
        Performs coarse alignment using machine vision
        
        Returns:
            Tuple[bool, Dict]: Success status and alignment data
        """
        # Get current positions
        fiber_position = await detect_fiber_position()
        waveguide_position = await detect_chip_waveguide()
        
        # Calculate required movement
        delta_x = waveguide_position.x - fiber_position.x
        delta_y = waveguide_position.y - fiber_position.y
        delta_z = waveguide_position.z - fiber_position.z
        
        # Apply calibration corrections
        corrected_deltas = self.calibration.apply_corrections(delta_x, delta_y, delta_z)
        
        # Move to coarse alignment position
        success = await self.motion_controller.move_relative(
            x=corrected_deltas[0],
            y=corrected_deltas[1],
            z=corrected_deltas[2],
            speed=self.calibration.coarse_movement_speed
        )
        
        result = {
            "success": success,
            "fiber_position": fiber_position,
            "waveguide_position": waveguide_position,
            "correction_applied": corrected_deltas
        }
        
        self.alignment_history.append({
            "phase": "coarse",
            "result": result
        })
        
        return success, result
    
    async def perform_fine_alignment(self) -> Tuple[bool, Dict]:
        """
        Performs fine alignment using optical power feedback
        
        Returns:
            Tuple[bool, Dict]: Success status and alignment data
        """
        # Initialize hill climbing optimization
        current_power = await self.motion_controller.get_optical_power()
        best_power = current_power
        best_position = await self.motion_controller.get_current_position()
        
        # Fine alignment uses a hill-climbing algorithm with decreasing step sizes
        step_sizes = [1.0, 0.5, 0.2, 0.1, 0.05]  # microns
        axes = ['x', 'y', 'z']
        
        for step_size in step_sizes:
            for _ in range(self.parameters.max_iterations // len(step_sizes)):
                improved = False
                
                for axis in axes:
                    # Try moving positive
                    await self.motion_controller.move_relative(**{axis: step_size})
                    new_power = await self.motion_controller.get_optical_power()
                    
                    if new_power > best_power:
                        best_power = new_power
                        best_position = await self.motion_controller.get_current_position()
                        improved = True
                    else:
                        # Move back and try negative
                        await self.motion_controller.move_relative(**{axis: -step_size})
                        await self.motion_controller.move_relative(**{axis: -step_size})
                        new_power = await self.motion_controller.get_optical_power()
                        
                        if new_power > best_power:
                            best_power = new_power
                            best_position = await self.motion_controller.get_current_position()
                            improved = True
                        else:
                            # Return to original position
                            await self.motion_controller.move_relative(**{axis: step_size})
                
                if not improved:
                    break
        
        # Move to best found position
        await self.motion_controller.move_absolute(**best_position)
        
        result = {
            "success": best_power >= self.parameters.optical_power_threshold,
            "final_power_dbm": best_power,
            "final_position": best_position,
            "iterations": len(self.alignment_history)
        }
        
        self.alignment_history.append({
            "phase": "fine",
            "result": result
        })
        
        self.is_aligned = result["success"]
        return result["success"], result
    
    async def align(self) -> Dict:
        """
        Performs complete alignment process including coarse and fine alignment
        
        Returns:
            Dict: Complete alignment results
        """
        self.alignment_history = []
        self.is_aligned = False
        
        # Step 1: Coarse alignment using vision
        coarse_success, coarse_data = await self.perform_coarse_alignment()
        if not coarse_success:
            return {
                "success": False,
                "phase": "coarse",
                "error": "Coarse alignment failed",
                "data": coarse_data
            }
        
        # Step 2: Fine alignment using optical power
        fine_success, fine_data = await self.perform_fine_alignment()
        
        return {
            "success": fine_success,
            "coarse_alignment": coarse_data,
            "fine_alignment": fine_data,
            "history": self.alignment_history
        }
```

### 2. Process Control System (`src/core/process`)

The Process Control System manages manufacturing workflows, job scheduling, and process monitoring.

```python
# src/core/process/workflow_manager.py
import asyncio
import uuid
from datetime import datetime
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field
from enum import Enum, auto
import logging

from ..database.models import WorkflowTemplate, ProcessInstance
from ..database.db import get_db_session
from ..alignment.alignment_engine import AlignmentEngine

logger = logging.getLogger(__name__)

class ProcessState(Enum):
    """States for process instances"""
    PENDING = auto()
    RUNNING = auto()
    PAUSED = auto()
    COMPLETED = auto()
    FAILED = auto()
    ABORTED = auto()


@dataclass
class ProcessStep:
    """Individual step in a process workflow"""
    id: str
    name: str
    description: str
    component: str  # Reference to component that executes this step
    parameters: Dict[str, Any] = field(default_factory=dict)
    timeout_seconds: Optional[int] = None
    retry_count: int = 0
    dependencies: List[str] = field(default_factory=list)  # IDs of steps that must complete first
    validation_rules: Dict[str, Any] = field(default_factory=dict)


@dataclass
class ProcessInstance:
    """Running instance of a process workflow"""
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    template_id: str = ""
    batch_id: Optional[str] = None
    state: ProcessState = ProcessState.PENDING
    current_step_id: Optional[str] = None
    steps: List[ProcessStep] = field(default_factory=list)
    step_results: Dict[str, Any] = field(default_factory=dict)
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def mark_step_complete(self, step_id: str, result: Dict[str, Any]) -> None:
        """Record the completion of a step with its results"""
        self.step_results[step_id] = {
            "status": "completed",
            "timestamp": datetime.now().isoformat(),
            "data": result
        }
    
    def mark_step_failed(self, step_id: str, error: str) -> None:
        """Record the failure of a step with error information"""
        self.step_results[step_id] = {
            "status": "failed",
            "timestamp": datetime.now().isoformat(),
            "error": error
        }
    
    def get_progress_percentage(self) -> float:
        """Calculate progress percentage"""
        if not self.steps:
            return 0.0
        
        completed_steps = sum(1 for step_id in self.step_results 
                             if self.step_results[step_id].get("status") == "completed")
        return (completed_steps / len(self.steps)) * 100


class WorkflowManager:
    """Manages process workflows and their execution"""
    
    def __init__(self):
        self.active_processes: Dict[str, ProcessInstance] = {}
        self.component_registry: Dict[str, Any] = {}
        self._shutdown_event = asyncio.Event()
        
    def register_component(self, name: str, component: Any) -> None:
        """Register a component that can execute process steps"""
        self.component_registry[name] = component
        logger.info(f"Registered component: {name}")
    
    async def load_workflow_template(self, template_id: str) -> WorkflowTemplate:
        """Load a workflow template from the database"""
        async with get_db_session() as session:
            template = await session.get(WorkflowTemplate, template_id)
            if not template:
                raise ValueError(f"Workflow template {template_id} not found")
            return template
    
    async def create_process_instance(self, template_id: str, batch_id: Optional[str] = None,
                                    metadata: Optional[Dict[str, Any]] = None) -> ProcessInstance:
        """Create a new process instance from a template"""
        template = await self.load_workflow_template(template_id)
        
        instance = ProcessInstance(
            template_id=template_id,
            batch_id=batch_id,
            steps=template.steps,
            metadata=metadata or {}
        )
        
        # Persist to database
        async with get_db_session() as session:
            db_instance = ProcessInstance(
                id=instance.id,
                template_id=template_id,
                batch_id=batch_id,
                state=ProcessState.PENDING.name,
                metadata=instance.metadata
            )
            session.add(db_instance)
            await session.commit()
        
        self.active_processes[instance.id] = instance
        logger.info(f"Created process instance {instance.id} from template {template_id}")
        return instance
    
    async def start_process(self, process_id: str) -> None:
        """Start execution of a process instance"""
        if process_id not in self.active_processes:
            raise ValueError(f"Process {process_id} not found")
        
        instance = self.active_processes[process_id]
        instance.state = ProcessState.RUNNING
        instance.started_at = datetime.now()
        
        # Update database
        async with get_db_session() as session:
            db_instance = await session.get(ProcessInstance, process_id)
            if db_instance:
                db_instance.state = ProcessState.RUNNING.name
                db_instance.started_at = instance.started_at
                await session.commit()
        
        # Start execution in background
        asyncio.create_task(self._execute_process(instance))
        logger.info(f"Started process {process_id}")
    
    async def pause_process(self, process_id: str) -> None:
        """Pause execution of a process instance"""
        if process_id not in self.active_processes:
            raise ValueError(f"Process {process_id} not found")
        
        instance = self.active_processes[process_id]
        instance.state = ProcessState.PAUSED
        
        # Update database
        async with get_db_session() as session:
            db_instance = await session.get(ProcessInstance, process_id)
            if db_instance:
                db_instance.state = ProcessState.PAUSED.name
                await session.commit()
        
        logger.info(f"Paused process {process_id}")
    
    async def resume_process(self, process_id: str) -> None:
        """Resume execution of a paused process instance"""
        if process_id not in self.active_processes:
            raise ValueError(f"Process {process_id} not found")
        
        instance = self.active_processes[process_id]
        if instance.state != ProcessState.PAUSED:
            raise ValueError(f"Process {process_id} is not paused")
        
        instance.state = ProcessState.RUNNING
        
        # Update database
        async with get_db_session() as session:
            db_instance = await session.get(ProcessInstance, process_id)
            if db_instance:
                db_instance.state = ProcessState.RUNNING.name
                await session.commit()
        
        # Resume execution in background
        asyncio.create_task(self._execute_process(instance))
        logger.info(f"Resumed process {process_id}")
    
    async def abort_process(self, process_id: str) -> None:
        """Abort execution of a process instance"""
        if process_id not in self.active_processes:
            raise ValueError(f"Process {process_id} not found")
        
        instance = self.active_processes[process_id]
        instance.state = ProcessState.ABORTED
        
        # Update database
        async with get_db_session() as session:
            db_instance = await session.get(ProcessInstance, process_id)
            if db_instance:
                db_instance.state = ProcessState.ABORTED.name
                await session.commit()
        
        logger.info(f"Aborted process {process_id}")
    
    async def get_process_status(self, process_id: str) -> Dict[str, Any]:
        """Get current status of a process instance"""
        if process_id not in self.active_processes:
            # Try loading from database
            async with get_db_session() as session:
                db_instance = await session.get(ProcessInstance, process_id)
                if not db_instance:
                    raise ValueError(f"Process {process_id} not found")
                
                # Build response from database record
                return {
                    "id": db_instance.id,
                    "template_id": db_instance.template_id,
                    "batch_id": db_instance.batch_id,
                    "state": db_instance.state,
                    "started_at": db_instance.started_at,
                    "completed_at": db_instance.completed_at,
                    "progress": None  # Can't calculate from DB record alone
                }
        
        instance = self.active_processes[process_id]
        return {
            "id": instance.id,
            "template_id": instance.template_id,
            "batch_id": instance.batch_id,
            "state": instance.state.name,
            "current_step": instance.current_step_id,
            "started_at": instance.started_at,
            "completed_at": instance.completed_at,
            "progress": instance.get_progress_percentage(),
            "step_results": {k: v.get("status") for k, v in instance.step_results.items()}
        }
    
    async def _execute_process(self, instance: ProcessInstance) -> None:
        """Execute a process instance step by step"""
        try:
            # Get steps that can be executed (no dependencies or dependencies completed)
            while instance.state == ProcessState.RUNNING:
                executable_steps = self._get_executable_steps(instance)
                if not executable_steps:
                    # Check if all steps are completed
                    if len(instance.step_results) == len(instance.steps):
                        instance.state = ProcessState.COMPLETED
                        instance.completed_at = datetime.now()
                        logger.info(f"Process {instance.id} completed successfully")
                        
                        # Update database
                        async with get_db_session() as session:
                            db_instance = await session.get(ProcessInstance, instance.id)
                            if db_instance:
                                db_instance.state = ProcessState.COMPLETED.name
                                db_instance.completed_at = instance.completed_at
                                await session.commit()
                        break
                    
                    # If there are unexecuted steps but none are executable, there may be a dependency cycle
                    if len(instance.step_results) < len(instance.steps):
                        logger.error(f"Process {instance.id} may have a dependency cycle")
                        instance.state = ProcessState.FAILED
                        
                        # Update database
                        async with get_db_session() as session:
                            db_instance = await session.get(ProcessInstance, instance.id)
                            if db_instance:
                                db_instance.state = ProcessState.FAILED.name
                                await session.commit()
                        break
                
                # Execute steps in parallel
                await asyncio.gather(*[self._execute_step(instance, step) for step in executable_steps])
                
                # Check if process should be paused after each iteration
                if instance.state != ProcessState.RUNNING:
                    break
                
                # Small delay to prevent CPU spinning
                await asyncio.sleep(0.1)
                
        except Exception as e:
            logger.exception(f"Error executing process {instance.id}: {str(e)}")
            instance.state = ProcessState.FAILED
            
            # Update database
            async with get_db_session() as session:
                db_instance = await session.get(ProcessInstance, instance.id)
                if db_instance:
                    db_instance.state = ProcessState.FAILED.name
                    await session.commit()
    
    def _get_executable_steps(self, instance: ProcessInstance) -> List[ProcessStep]:
        """Get steps that can be executed"""
        executable = []
        
        for step in instance.steps:
            # Skip steps that have already been executed
            if step.id in instance.step_results:
                continue
            
            # Check if all dependencies are satisfied
            dependencies_satisfied = True
            for dep_id in step.dependencies:
                if dep_id not in instance.step_results or instance.step_results[dep_id].get("status") != "completed":
                    dependencies_satisfied = False
                    break
            
            if dependencies_satisfied:
                executable.append(step)
        
        return executable
    
    async def _execute_step(self, instance: ProcessInstance, step: ProcessStep) -> None:
        """Execute a single process step"""
        instance.current_step_id = step.id
        logger.info(f"Executing step {step.id} ({step.name}) in process {instance.id}")
        
        try:
            # Get component that executes this step
            component = self.component_registry.get(step.component)
            if not component:
                raise ValueError(f"Component {step.component} not found for step {step.id}")
            
            # Execute step with timeout if specified
            if step.timeout_seconds:
                try:
                    result = await asyncio.wait_for(
                        component.execute(step.parameters),
                        timeout=step.timeout_seconds
                    )
                except asyncio.TimeoutError:
                    raise TimeoutError(f"Step {step.id} timed out after {step.timeout_seconds} seconds")
            else:
                result = await component.execute(step.parameters)
            
            # Validate results if validation rules are specified
            if step.validation_rules:
                self._validate_step_result(result, step.validation_rules)
            
            # Mark step as complete
            instance.mark_step_complete(step.id, result)
            logger.info(f"Step {step.id} completed successfully in process {instance.id}")
            
        except Exception as e:
            logger.error(f"Error executing step {step.id} in process {instance.id}: {str(e)}")
            
            # Handle retry logic
            current_retry = instance.step_results.get(step.id, {}).get("retry_count", 0)
            if current_retry < step.retry_count:
                logger.info(f"Retrying step {step.id} (attempt {current_retry + 1}/{step.retry_count})")
                instance.step_results[step.id] = {
                    "status": "retrying",
                    "retry_count": current_retry + 1,
                    "timestamp": datetime.now().isoformat(),
                    "error": str(e)
                }
                return
            
            # Mark step as failed
            instance.mark_step_failed(step.id, str(e))
            
            # Mark process as failed if this is a critical error
            if step.validation_rules.get("critical", False):
                instance.state = ProcessState.FAILED
                logger.error(f"Process {instance.id} failed due to critical step failure: {step.id}")
    
    def _validate_step_result(self, result: Dict[str, Any], rules: Dict[str, Any]) -> None:
        """Validate step result against rules"""
        for key, rule in rules.items():
            if key == "critical":
                continue  # Special flag, not a validation rule
                
            if key not in result:
                if rules.get("required_fields", []) and key in rules["required_fields"]:
                    raise ValueError(f"Required field {key} missing from result")
                continue
            
            value = result[key]
            
            # Check min/max for numeric values
            if isinstance(value, (int, float)):
                if "min" in rule and value < rule["min"]:
                    raise ValueError(f"Value {value} for {key} is below minimum {rule['min']}")
                if "max" in rule and value > rule["max"]:
                    raise ValueError(f"Value {value} for {key} is above maximum {rule['max']}")
            
            # Check allowed values
            if "allowed_values" in rule and value not in rule["allowed_values"]:
                raise ValueError(f"Value {value} for {key} not in allowed values {rule['allowed_values']}")
            
            # Check regex pattern for strings
            if isinstance(value, str) and "pattern" in rule:
                import re
                if not re.match(rule["pattern"], value):
                    raise ValueError(f"Value {value} for {key} does not match pattern {rule['pattern']}")
```

### 3. C++ High-Performance Alignment Module (`src/cpp/alignment`)

For performance-critical operations, we use C++ to achieve real-time control and processing.

```cpp
// src/cpp/alignment/fast_align.h
#pragma once

#include <vector>
#include <array>
#include <string>
#include <functional>
#include <memory>
#include <chrono>
#include <optional>
#include <mutex>

namespace OpenManufacturing {
namespace Alignment {

struct Point3D {
    double x;
    double y;
    double z;
};

struct AlignmentResult {
    bool success;
    Point3D final_position;
    double optical_power_dbm;
    std::chrono::milliseconds elapsed_time;
    int iterations;
    std::vector<Point3D> trajectory;
    std::string error_message;
};

using OpticalPowerCallback = std::function<double()>;
using MotionCallback = std::function<bool(const Point3D&)>;

class FastAlignmentEngine {
public:
    FastAlignmentEngine(
        OpticalPowerCallback power_callback,
        MotionCallback motion_callback,
        double position_tolerance_um = 0.05,
        double optical_threshold_dbm = -3.0,
        int max_iterations = 100
    );
    
    ~FastAlignmentEngine();
    
    /**
     * Gradient descent alignment to maximize optical power
     */
    AlignmentResult alignGradientDescent(
        const Point3D& start_position,
        double initial_step_size = 0.5,
        double step_reduction_factor = 0.5,
        int max_step_reductions = 5
    );
    
    /**
     * Spiral search pattern for initial alignment
     */
    AlignmentResult alignSpiralSearch(
        const Point3D& center,
        double max_radius_um = 10.0,
        double step_size_um = 0.5,
        int spiral_points = 100
    );
    
    /**
     * Combined approach: spiral search followed by gradient descent
     */
    AlignmentResult alignCombined(
        const Point3D& start_position,
        double max_radius_um = 10.0,
        double spiral_step_um = 1.0,
        double descent_initial_step = 0.2
    );
    
    /**
     * Stop any ongoing alignment process
     */
    void stopAlignment();
    
    /**
     * Set the alignment parameters
     */
    void setParameters(
        double position_tolerance_um,
        double optical_threshold_dbm,
        int max_iterations
    );

private:
    struct Impl;
    std::unique_ptr<Impl> pImpl;
    
    std::mutex align_mutex_;
    bool stop_requested_ = false;
    
    Point3D computeGradient(const Point3D& position, double step_size);
    double measureOpticalPower();
    bool moveToPosition(const Point3D& position);
};

} // namespace Alignment
} // namespace OpenManufacturing
```

```cpp
// src/cpp/alignment/fast_align.cpp
#include "fast_align.h"
#include <iostream>
#include <cmath>
#include <algorithm>
#include <chrono>

namespace OpenManufacturing {
namespace Alignment {

struct FastAlignmentEngine::Impl {
    OpticalPowerCallback getPower;
    MotionCallback moveToPosition;
    double position_tolerance_um;
    double optical_threshold_dbm;
    int max_iterations;
    
    explicit Impl(
        OpticalPowerCallback power_cb,
        MotionCallback motion_cb,
        double pos_tolerance_um,
        double optical_threshold,
        int max_iter
    ) : getPower(std::move(power_cb)),
        moveToPosition(std::move(motion_cb)),
        position_tolerance_um(pos_tolerance_um),
        optical_threshold_dbm(optical_threshold),
        max_iterations(max_iter) {}
};

FastAlignmentEngine::FastAlignmentEngine(
    OpticalPowerCallback power_callback,
    MotionCallback motion_callback,
    double position_tolerance_um,
    double optical_threshold_dbm,
    int max_iterations
) : pImpl(std::make_unique<Impl>(
        std::move(power_callback),
        std::move(motion_callback),
        position_tolerance_um,
        optical_threshold_dbm,
        max_iterations
    )) {}

FastAlignmentEngine::~FastAlignmentEngine() = default;

double FastAlignmentEngine::measureOpticalPower() {
    return pImpl->getPower();
}

bool FastAlignmentEngine::moveToPosition(const Point3D& position) {
    return pImpl->moveToPosition(position);
}

Point3D FastAlignmentEngine::computeGradient(const Point3D& position, double step_size) {
    // Measure optical power at current position
    double center_power = measureOpticalPower();
    
    // Initialize gradient vector
    Point3D gradient = {0.0, 0.0, 0.0};
    
    // Sample points along each axis to compute gradient
    const std::array<Point3D, 6> sample_offsets = {{
        {step_size, 0, 0},
        {-step_size, 0, 0},
        {0, step_size, 0},
        {0, -step_size, 0},
        {0, 0, step_size},
        {0, 0, -step_size}
    }};
    
    for (size_t i = 0; i < sample_offsets.size(); i += 2) {
        // Positive direction
        Point3D pos_sample = position;
        pos_sample.x += sample_offsets[i].x;
        pos_sample.y += sample_offsets[i].y;
        pos_sample.z += sample_offsets[i].z;
        
        moveToPosition(pos_sample);
        double pos_power = measureOpticalPower();
        
        // Negative direction
        Point3D neg_sample = position;
        neg_sample.x += sample_offsets[i+1].x;
        neg_sample.y += sample_offsets[i+1].y;
        neg_sample.z += sample_offsets[i+1].z;
        
        moveToPosition(neg_sample);
        double neg_power = measureOpticalPower();
        
        // Calculate symmetric difference for this axis
        double axis_gradient = (pos_power - neg_power) / (2.0 * step_size);
        
        // Update gradient component
        if (i == 0) gradient.x = axis_gradient;
        else if (i == 2) gradient.y = axis_gradient;
        else if (i == 4) gradient.z = axis_gradient;
    }
    
    // Return to original position
    moveToPosition(position);
    
    return gradient;
}

AlignmentResult FastAlignmentEngine::alignGradientDescent(
    const Point3D& start_position,
    double initial_step_size,
    double step_reduction_factor,
    int max_step_reductions
) {
    std::lock_guard<std::mutex> lock(align_mutex_);
    stop_requested_ = false;
    
    AlignmentResult result;
    result.success = false;
    result.trajectory.push_back(start_position);
    
    auto start_time = std::chrono::high_resolution_clock::now();
    
    // Move to start position
    if (!moveToPosition(start_position)) {
        result.error_message = "Failed to move to start position";
        return result;
    }
    
    Point3D current_pos = start_position;
    double current_power = measureOpticalPower();
    double best_power = current_power;
    Point3D best_pos = current_pos;
    
    double step_size = initial_step_size;
    int iterations = 0;
    int step_reductions = 0;
    
    // Gradient descent loop
    while (iterations < pImpl->max_iterations && step_reductions < max_step_reductions && !stop_requested_) {
        // Compute gradient
        Point3D gradient = computeGradient(current_pos, step_size * 0.5);
        
        // Compute gradient magnitude
        double gradient_mag = std::sqrt(gradient.x*gradient.x + 
                                       gradient.y*gradient.y + 
                                       gradient.z*gradient.z);
        
        // If gradient is very small, reduce step size
        if (gradient_mag < 1e-6) {
            step_size *= step_reduction_factor;
            step_reductions++;
            continue;
        }
        
        // Normalize gradient
        gradient.x /= gradient_mag;
        gradient.y /= gradient_mag;
        gradient.z /= gradient_mag;
        
        // Compute new position
        Point3D new_pos = {
            current_pos.x + step_size * gradient.x,
            current_pos.y + step_size * gradient.y,
            current_pos.z + step_size * gradient.z
        };
        
        // Move to new position
        if (!moveToPosition(new_pos)) {
            result.error_message = "Failed to move during gradient descent";
            break;
        }
        
        // Measure new power
        double new_power = measureOpticalPower();
        
        // Update trajectory
        result.trajectory.push_back(new_pos);
        
        // If power improved, accept the move
        if (new_power > current_power) {
            current_pos = new_pos;
            current_power = new_power;
            
            // Update best position if this is the best so far
            if (new_power > best_power) {
                best_power = new_power;
                best_pos = new_pos;
            }
        } else {
            // Power didn't improve, reduce step size
            step_size *= step_reduction_factor;
            step_reductions++;
            
            // Move back to previous position
            moveToPosition(current_pos);
        }
        
        iterations++;
        
        // Check if we've reached the target optical power
        if (best_power >= pImpl->optical_threshold_dbm) {
            result.success = true;
            break;
        }
    }
    
    // Move to best position found
    moveToPosition(best_pos);
    
    auto end_time = std::chrono::high_resolution_clock::now();
    result.elapsed_time = std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time);
    result.iterations = iterations;
    result.final_position = best_pos;
    result.optical_power_dbm = best_power;
    
    // Set success based on optical power threshold
    result.success = best_power >= pImpl->optical_threshold_dbm;
    
    return result;
}

AlignmentResult FastAlignmentEngine::alignSpiralSearch(
    const Point3D& center,
    double max_radius_um,
    double step_size_um,
    int spiral_points
) {
    std::lock_guard<std::mutex> lock(align_mutex_);
    stop_requested_ = false;
    
    AlignmentResult result;
    result.success = false;
    result.trajectory.push_back(center);
    
    auto start_time = std::chrono::high_resolution_clock::now();
    
    // Move to center position
    if (!moveToPosition(center)) {
        result.error_message = "Failed to move to center position";
        return result;
    }
    
    double current_power = measureOpticalPower();
    double best_power = current_power;
    Point3D best_pos = center;
    
    // Spiral search in XY plane
    for (int i = 0; i < spiral_points && !stop_requested_; ++i) {
        // Parametric equation for spiral
        double t = step_size_um * i;
        double r = t;
        
        // Ensure we don't exceed max radius
        if (r > max_radius_um) break;
        
        // Convert to Cartesian coordinates
        double x = center.x + r * std::cos(t);
        double y = center.y + r * std::sin(t);
        
        Point3D new_pos = {x, y, center.z};
        
        // Move to new position
        if (!moveToPosition(new_pos)) {
            continue;  // Skip this point if movement fails
        }
        
        // Measure new power
        double new_power = measureOpticalPower();
        
        // Update trajectory
        result.trajectory.push_back(new_pos);
        
        // Update best position if this is the best so far
        if (new_power > best_power) {
            best_power = new_power;
            best_pos = new_pos;
            
            // Check if we've reached the target optical power
            if (best_power >= pImpl->optical_threshold_dbm) {
                result.success = true;
                break;
            }
        }
    }
    
    // Now search in Z at the best XY position
    if (!stop_requested_) {
        moveToPosition(best_pos);
        
        for (double z_offset = -max_radius_um; z_offset <= max_radius_um && !stop_requested_; z_offset += step_size_um) {
            Point3D new_pos = {best_pos.x, best_pos.y, center.z + z_offset};
            
            // Move to new position
            if (!moveToPosition(new_pos)) {
                continue;  // Skip this point if movement fails
            }
            
            // Measure new power
            double new_power = measureOpticalPower();
            
            // Update trajectory
            result.trajectory.push_back(new_pos);
            
            // Update best position if this is the best so far
            if (new_power > best_power) {
                best_power = new_power;
                best_pos = new_pos;
                
                // Check if we've reached the target optical power
                if (best_power >= pImpl->optical_threshold_dbm) {
                    result.success = true;
                    break;
                }
            }
        }
    }
    
    // Move to best position found
    moveToPosition(best_pos);
    
    auto end_time = std::chrono::high_resolution_clock::now();
    result.elapsed_time = std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time);
    result.iterations = static_cast<int>(result.trajectory.size());
    result.final_position = best_pos;
    result.optical_power_dbm = best_power;
    
    // Set success based on optical power threshold
    result.success = best_power >= pImpl->optical_threshold_dbm;
    
    return result;
}

AlignmentResult FastAlignmentEngine::alignCombined(
    const Point3D& start_position,
    double max_radius_um,
    double spiral_step_um,
    double descent_initial_step
) {
    // First perform spiral search to find approximate position
    auto spiral_result = alignSpiralSearch(start_position, max_radius_um, spiral_step_um);
    
    // If spiral search was successful or found a promising position, refine with gradient descent
    if (spiral_result.success || spiral_result.optical_power_dbm > -20.0) {
        auto descent_result = alignGradientDescent(spiral_result.final_position, descent_initial_step);
        
        // Combine results
        descent_result.trajectory.insert(
            descent_result.trajectory.begin(),
            spiral_result.trajectory.begin(),
            spiral_result.trajectory.end()
        );
        
        return descent_result;
    }
    
    // If spiral search failed completely, return its result
    return spiral_result;
}

void FastAlignmentEngine::stopAlignment() {
    stop_requested_ = true;
}

void FastAlignmentEngine::setParameters(
    double position_tolerance_um,
    double optical_threshold_dbm,
    int max_iterations
) {
    pImpl->position_tolerance_um = position_tolerance_um;
    pImpl->optical_threshold_dbm = optical_threshold_dbm;
    pImpl->max_iterations = max_iterations;
}

} // namespace Alignment
} // namespace OpenManufacturing
```

### 4. API Layer (`src/api/routes`)

The REST API provides access to the platform's functionality.

```python
# src/api/routes/alignment.py
from fastapi import APIRouter, Depends, HTTPException, BackgroundTasks
from typing import Dict, List, Optional, Any
from pydantic import BaseModel
import uuid
import asyncio

from ..dependencies import get_alignment_service, get_process_manager
from ...core.alignment import AlignmentService, AlignmentParameters
from ...core.process import WorkflowManager

router = APIRouter(prefix="/api/alignment", tags=["alignment"])

class AlignmentRequest(BaseModel):
    """Request model for alignment operations"""
    device_id: str
    parameters: Optional[Dict[str, Any]] = None
    process_id: Optional[str] = None
    batch_id: Optional[str] = None
    metadata: Optional[Dict[str, Any]] = None

class AlignmentResponse(BaseModel):
    """Response model for alignment operations"""
    request_id: str
    status: str
    process_id: Optional[str] = None
    message: Optional[str] = None

class AlignmentResult(BaseModel):
    """Detailed alignment result"""
    request_id: str
    device_id: str
    success: bool
    optical_power_dbm: float
    position: Dict[str, float]
    duration_ms: int
    timestamp: str
    process_id: Optional[str] = None
    error: Optional[str] = None

@router.post("/align", response_model=AlignmentResponse)
async def start_alignment(
    request: AlignmentRequest,
    background_tasks: BackgroundTasks,
    alignment_service: AlignmentService = Depends(get_alignment_service),
    process_manager: WorkflowManager = Depends(get_process_manager)
):
    """Start a new alignment operation"""
    request_id = str(uuid.uuid4())
    
    # Check if process_id is provided and valid
    process_id = request.process_id
    if process_id:
        try:
            process_status = await process_manager.get_process_status(process_id)
            if process_status["state"] not in ["RUNNING", "PENDING"]:
                raise HTTPException(status_code=400, detail=f"Process {process_id} is not in a valid state")
        except ValueError:
            raise HTTPException(status_code=404, detail=f"Process {process_id} not found")
    
    # Convert request parameters to alignment parameters
    if request.parameters:
        try:
            params = AlignmentParameters(**request.parameters)
        except Exception as e:
            raise HTTPException(status_code=400, detail=f"Invalid parameters: {str(e)}")
    else:
        params = AlignmentParameters()  # Use defaults
    
    # Schedule alignment in background
    background_tasks.add_task(
        alignment_service.align_device,
        request_id=request_id,
        device_id=request.device_id,
        parameters=params,
        process_id=process_id,
        metadata=request.metadata
    )
    
    return AlignmentResponse(
        request_id=request_id,
        status="scheduled",
        process_id=process_id,
        message="Alignment operation scheduled"
    )

@router.get("/status/{request_id}", response_model=Optional[AlignmentResult])
async def get_alignment_status(
    request_id: str,
    alignment_service: AlignmentService = Depends(get_alignment_service)
):
    """Get status of an alignment operation"""
    result = alignment_service.get_alignment_result(request_id)
    if not result:
        raise HTTPException(status_code=404, detail=f"Alignment request {request_id} not found")
    return result

@router.get("/history/{device_id}", response_model=List[AlignmentResult])
async def get_alignment_history(
    device_id: str,
    limit: int = 10,
    alignment_service: AlignmentService = Depends(get_alignment_service)
):
    """Get alignment history for a device"""
    history = alignment_service.get_alignment_history(device_id, limit)
    return history

@router.post("/cancel/{request_id}", response_model=AlignmentResponse)
async def cancel_alignment(
    request_id: str,
    alignment_service: AlignmentService = Depends(get_alignment_service)
):
    """Cancel an ongoing alignment operation"""
    success = alignment_service.cancel_alignment(request_id)
    if not success:
        raise HTTPException(status_code=404, detail=f"Alignment request {request_id} not found or already completed")
    
    return AlignmentResponse(
        request_id=request_id,
        status="cancelled",
        message="Alignment operation cancelled"
    )
```

### 5. Tauri UI Frontend (`src/ui/src`)

The Tauri desktop application provides a modern UI for interacting with the platform.

```tsx
// src/ui/src/components/AlignmentDashboard.tsx
import React, { useState, useEffect } from 'react';
import { Grid, Card, CardContent, Typography, Button, Box, CircularProgress, Tabs, Tab } from '@mui/material';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts';
import { invoke } from '@tauri-apps/api/tauri';
import { listen } from '@tauri-apps/api/event';

import DeviceSelector from './DeviceSelector';
import AlignmentParameters from './AlignmentParameters';
import ProcessMonitor from './ProcessMonitor';
import AlignmentHistory from './AlignmentHistory';
import { Device, AlignmentResult, AlignmentParams } from '../types';

interface TabPanelProps {
  children?: React.ReactNode;
  index: number;
  value: number;
}

function TabPanel(props: TabPanelProps) {
  const { children, value, index, ...other } = props;

  return (
    <div
      role="tabpanel"
      hidden={value !== index}
      id={`alignment-tabpanel-${index}`}
      aria-labelledby={`alignment-tab-${index}`}
      {...other}
    >
      {value === index && <Box sx={{ p: 3 }}>{children}</Box>}
    </div>
  );
}

const AlignmentDashboard: React.FC = () => {
  const [devices, setDevices] = useState<Device[]>([]);
  const [selectedDevice, setSelectedDevice] = useState<Device | null>(null);
  const [alignmentParams, setAlignmentParams] = useState<AlignmentParams>({
    positionToleranceUm: 0.1,
    angleToleranceDeg: 0.05,
    opticalPowerThreshold: -3.0,
    maxIterations: 100,
    useMachineLearning: true,
  });
  const [isAligning, setIsAligning] = useState(false);
  const [currentResult, setCurrentResult] = useState<AlignmentResult | null>(null);
  const [alignmentHistory, setAlignmentHistory] = useState<AlignmentResult[]>([]);
  const [powerData, setPowerData] = useState<any[]>([]);
  const [tabValue, setTabValue] = useState(0);
  const [requestId, setRequestId] = useState<string | null>(null);

  // Fetch connected devices
  useEffect(() => {
    const fetchDevices = async () => {
      try {
        const deviceList = await invoke<Device[]>('get_connected_devices');
        setDevices(deviceList);
        if (deviceList.length > 0) {
          setSelectedDevice(deviceList[0]);
        }
      } catch (error) {
        console.error('Failed to fetch devices:', error);
      }
    };

    fetchDevices();
    const interval = setInterval(fetchDevices, 30000);  // Refresh every 30 seconds
    return () => clearInterval(interval);
  }, []);

  // Listen for alignment updates
  useEffect(() => {
    const unlisten = listen<AlignmentResult>('alignment_update', (event) => {
      setCurrentResult(event.payload);

      // Update power data for chart
      setPowerData(prevData => {
        const newPoint = {
          time: new Date().toLocaleTimeString(),
          power: event.payload.opticalPowerDbm,
          x: event.payload.position.x,
          y: event.payload.position.y,
          z: event.payload.position.z,
        };
        return [...prevData, newPoint].slice(-50);  // Keep last 50 points
      });

      // If alignment is complete, update history and reset current state
      if (event.payload.status === 'completed' || event.payload.status === 'failed') {
        setIsAligning(false);
        setRequestId(null);
        fetchAlignmentHistory();
      }
    });

    return () => {
      unlisten.then(unsub => unsub());
    };
  }, []);

  // Fetch alignment history when device changes
  useEffect(() => {
    if (selectedDevice) {
      fetchAlignmentHistory();
    }
  }, [selectedDevice]);

  const fetchAlignmentHistory = async () => {
    if (!selectedDevice) return;
    
    try {
      const history = await invoke<AlignmentResult[]>('get_alignment_history', {
        deviceId: selectedDevice.id,
        limit: 10
      });
      setAlignmentHistory(history);
    } catch (error) {
      console.error('Failed to fetch alignment history:', error);
    }
  };

  const handleStartAlignment = async () => {
    if (!selectedDevice) return;
    
    try {
      setIsAligning(true);
      setPowerData([]);
      
      const result = await invoke<{ requestId: string }>('start_alignment', {
        deviceId: selectedDevice.id,
        parameters: alignmentParams
      });
      
      setRequestId(result.requestId);
    } catch (error) {
      console.error('Failed to start alignment:', error);
      setIsAligning(false);
    }
  };

  const handleCancelAlignment = async () => {
    if (!requestId) return;
    
    try {
      await invoke('cancel_alignment', { requestId });
      setIsAligning(false);
      setRequestId(null);
    } catch (error) {
      console.error('Failed to cancel alignment:', error);
    }
  };

  const handleTabChange = (event: React.SyntheticEvent, newValue: number) => {
    setTabValue(newValue);
  };

  return (
    <Grid container spacing={3}>
      <Grid item xs={12}>
        <Card>
          <CardContent>
            <Typography variant="h5" component="h2" gutterBottom>
              Optical Packaging Alignment Dashboard
            </Typography>
            
            <Box sx={{ borderBottom: 1, borderColor: 'divider' }}>
              <Tabs value={tabValue} onChange={handleTabChange} aria-label="alignment tabs">
                <Tab label="Alignment Control" id="alignment-tab-0" />
                <Tab label="Process Monitor" id="alignment-tab-1" />
                <Tab label="History" id="alignment-tab-2" />
              </Tabs>
            </Box>
            
            <TabPanel value={tabValue} index={0}>
              <Grid container spacing={3}>
                <Grid item xs={12} md={4}>
                  <DeviceSelector 
                    devices={devices} 
                    selectedDevice={selectedDevice}
                    onDeviceChange={setSelectedDevice}
                  />
                  
                  <Box mt={3}>
                    <AlignmentParameters 
                      parameters={alignmentParams}
                      onChange={setAlignmentParams}
                      disabled={isAligning}
                    />
                  </Box>
                  
                  <Box mt={3} display="flex" justifyContent="center">
                    {isAligning ? (
                      <Button 
                        variant="contained" 
                        color="secondary"
                        onClick={handleCancelAlignment}
                        startIcon={<CircularProgress size={20} color="inherit" />}
                      >
                        Cancel Alignment
                      </Button>
                    ) : (
                      <Button 
                        variant="contained" 
                        color="primary"
                        onClick={handleStartAlignment}
                        disabled={!selectedDevice}
                      >
                        Start Alignment
                      </Button>
                    )}
                  </Box>
                </Grid>
                
                <Grid item xs={12} md={8}>
                  <Card>
                    <CardContent>
                      <Typography variant="h6" gutterBottom>
                        Real-time Optical Power
                      </Typography>
                      <ResponsiveContainer width="100%" height={300}>
                        <LineChart data={powerData}>
                          <CartesianGrid strokeDasharray="3 3" />
                          <XAxis dataKey="time" />
                          <YAxis yAxisId="left" orientation="left" domain={['auto', 'auto']} />
                          <Tooltip />
                          <Legend />
                          <Line 
                            yAxisId="left"
                            type="monotone" 
                            dataKey="power" 
                            stroke="#8884d8" 
                            name="Optical Power (dBm)" 
                            dot={false}
                          />
                        </LineChart>
                      </ResponsiveContainer>
                    </CardContent>
                  </Card>
                  
                  {currentResult && (
                    <Box mt={3}>
                      <Card>
                        <CardContent>
                          <Typography variant="h6" gutterBottom>
                            Current Alignment Status
                          </Typography>
                          <Grid container spacing={2}>
                            <Grid item xs={6}>
                              <Typography variant="body2" color="textSecondary">Status</Typography>
                              <Typography variant="body1">
                                {currentResult.status === 'completed' ? (
                                  <span style={{ color: 'green' }}>Completed Successfully</span>
                                ) : currentResult.status === 'failed' ? (
                                  <span style={{ color: 'red' }}>Failed</span>
                                ) : (
                                  <span style={{ color: 'blue' }}>In Progress</span>
                                )}
                              </Typography>
                            </Grid>
                            <Grid item xs={6}>
                              <Typography variant="body2" color="textSecondary">Optical Power</Typography>
                              <Typography variant="body1">{currentResult.opticalPowerDbm.toFixed(2)} dBm</Typography>
                            </Grid>
                            <Grid item xs={4}>
                              <Typography variant="body2" color="textSecondary">X Position</Typography>
                              <Typography variant="body1">{currentResult.position.x.toFixed(3)} μm</Typography>
                            </Grid>
                            <Grid item xs={4}>
                              <Typography variant="body2" color="textSecondary">Y Position</Typography>
                              <Typography variant="body1">{currentResult.position.y.toFixed(3)} μm</Typography>
                            </Grid>
                            <Grid item xs={4}>
                              <Typography variant="body2" color="textSecondary">Z Position</Typography>
                              <Typography variant="body1">{currentResult.position.z.toFixed(3)} μm</Typography>
                            </Grid>
                            <Grid item xs={6}>
                              <Typography variant="body2" color="textSecondary">Duration</Typography>
                              <Typography variant="body1">{(currentResult.durationMs / 1000).toFixed(1)} s</Typography>
                            </Grid>
                            <Grid item xs={6}>
                              <Typography variant="body2" color="textSecondary">Timestamp</Typography>
                              <Typography variant="body1">{new Date(currentResult.timestamp).toLocaleString()}</Typography>
                            </Grid>
                            {currentResult.error && (
                              <Grid item xs={12}>
                                <Typography variant="body2" color="error">Error: {currentResult.error}</Typography>
                              </Grid>
                            )}
                          </Grid>
                        </CardContent>
                      </Card>
                    </Box>
                  )}
                </Grid>
              </Grid>
            </TabPanel>
            
            <TabPanel value={tabValue} index={1}>
              <ProcessMonitor />
            </TabPanel>
            
            <TabPanel value={tabValue} index={2}>
              <AlignmentHistory history={alignmentHistory} onRefresh={fetchAlignmentHistory} />
            </TabPanel>
          </CardContent>
        </Card>
      </Grid>
    </Grid>
  );
};

export default AlignmentDashboard;
```

### 6. Testing Framework (`tests/`)

The project includes a comprehensive testing suite to ensure reliability and code quality.

```python
# tests/unit/alignment/test_alignment_engine.py
import pytest
import numpy as np
from unittest.mock import MagicMock, patch
from datetime import datetime

from openmanufacturing.core.alignment.alignment_engine import AlignmentEngine, AlignmentParameters
from openmanufacturing.core.process.calibration import CalibrationProfile
from openmanufacturing.core.hardware.motion_controller import MotionController

@pytest.fixture
def mock_motion_controller():
    mock = MagicMock(spec=MotionController)
    
    # Setup mock behavior for move_relative
    mock.move_relative.return_value = True
    
    # Setup mock behavior for get_optical_power
    # This simulates a peak at a specific position
    def simulated_power(*args, **kwargs):
        pos = mock.get_current_position()
        # Gaussian peak centered at (0, 0, 0)
        peak_value = -2.0  # dBm
        width = 1.0  # μm
        distance = np.sqrt(pos["x"]**2 + pos["y"]**2 + pos["z"]**2)
        power = peak_value * np.exp(-(distance**2) / (2 * width**2))
        return power
    
    mock.get_optical_power.side_effect = simulated_power
    
    # Setup mock behavior for get_current_position
    current_position = {"x": 1.0, "y": 1.0, "z": 1.0}
    
    def get_pos():
        return current_position.copy()
    
    def move_rel(x=0, y=0, z=0, **kwargs):
        current_position["x"] += x
        current_position["y"] += y
        current_position["z"] += z
        return True
    
    def move_abs(x=None, y=None, z=None, **kwargs):
        if x is not None:
            current_position["x"] = x
        if y is not None:
            current_position["y"] = y
        if z is not None:
            current_position["z"] = z
        return True
    
    mock.get_current_position.side_effect = get_pos
    mock.move_relative.side_effect = move_rel
    mock.move_absolute.side_effect = move_abs
    
    return mock

@pytest.fixture
def mock_vision_system():
    with patch('openmanufacturing.core.vision.image_processing.detect_fiber_position') as mock_fiber, \
         patch('openmanufacturing.core.vision.image_processing.detect_chip_waveguide') as mock_waveguide:
        
        # Set up mock positions
        fiber_pos = MagicMock()
        fiber_pos.x = 2.0
        fiber_pos.y = 2.0
        fiber_pos.z = 2.0
        
        chip_pos = MagicMock()
        chip_pos.x = 0.0
        chip_pos.y = 0.0
        chip_pos.z = 0.0
        
        mock_fiber.return_value = fiber_pos
        mock_waveguide.return_value = chip_pos
        
        yield

@pytest.fixture
def alignment_engine(mock_motion_controller):
    calibration = CalibrationProfile()
    params = AlignmentParameters(
        position_tolerance_um=0.1,
        angle_tolerance_deg=0.05,
        optical_power_threshold=-3.0,
        max_iterations=50
    )
    
    engine = AlignmentEngine(
        motion_controller=mock_motion_controller,
        calibration_profile=calibration,
        parameters=params
    )
    
    return engine

class TestAlignmentEngine:
    
    @pytest.mark.asyncio
    async def test_coarse_alignment(self, alignment_engine, mock_motion_controller, mock_vision_system):
        # Perform coarse alignment
        success, result = await alignment_engine.perform_coarse_alignment()
        
        # Verify success
        assert success is True
        
        # Verify positions
        assert "fiber_position" in result
        assert "waveguide_position" in result
        assert "correction_applied" in result
        
        # Verify motion controller was called with correct movements
        # The correction should move fiber towards waveguide (from 2,2,2 towards 0,0,0)
        position_after_move = mock_motion_controller.get_current_position()
        assert position_after_move["x"] < 2.0
        assert position_after_move["y"] < 2.0
        assert position_after_move["z"] < 2.0
    
    @pytest.mark.asyncio
    async def test_fine_alignment(self, alignment_engine, mock_motion_controller):
        # Set initial position away from optimal
        mock_motion_controller.move_absolute(x=1.0, y=1.0, z=1.0)
        
        # Perform fine alignment
        success, result = await alignment_engine.perform_fine_alignment()
        
        # Verify success
        assert success is True
        
        # Verify the alignment found a position with good optical power
        assert result["final_power_dbm"] >= alignment_engine.parameters.optical_power_threshold
        
        # Verify the final position is close to the optimal position (0,0,0)
        assert abs(result["final_position"]["x"]) < 0.2
        assert abs(result["final_position"]["y"]) < 0.2
        assert abs(result["final_position"]["z"]) < 0.2
    
    @pytest.mark.asyncio
    async def test_complete_alignment_process(self, alignment_engine, mock_motion_controller, mock_vision_system):
        # Set initial position away from optimal
        mock_motion_controller.move_absolute(x=1.5, y=1.5, z=1.5)
        
        # Perform complete alignment
        result = await alignment_engine.align()
        
        # Verify success
        assert result["success"] is True
        
        # Verify both coarse and fine alignment data are present
        assert "coarse_alignment" in result
        assert "fine_alignment" in result
        
        # Verify alignment history is recorded
        assert "history" in result
        assert len(result["history"]) >= 2  # At least coarse and fine phases
        
        # Check that process moved to a position with good optical power
        assert result["fine_alignment"]["final_power_dbm"] >= alignment_engine.parameters.optical_power_threshold
        
        # Verify final position is close to optimal
        final_pos = result["fine_alignment"]["final_position"]
        assert abs(final_pos["x"]) < 0.2
        assert abs(final_pos["y"]) < 0.2
        assert abs(final_pos["z"]) < 0.2
```

### 7. Documentation (`docs/`)

Comprehensive documentation including API references, architecture diagrams, and user guides.

```markdown
# Optical Packaging & Assembly Platform Documentation

## Architecture Overview

The OpenManufacturing platform is designed with a modular architecture that separates concerns while providing high performance for critical operations. The platform consists of the following major components:

1. **Core Python Modules**: Provide business logic, process management, and high-level control
2. **C++ Components**: Handle performance-critical operations such as real-time alignment
3. **REST API**: Exposes platform functionality to other systems
4. **Tauri UI**: Provides desktop application interface for monitoring and control
5. **Database Layer**: Stores process data, alignment results, and configuration
6. **Integration Layer**: Connects with external systems like ERPs, PLCs, and vision systems

### System Architecture Diagram

![System Architecture](../images/architecture_diagram.png)

## Core Components

### Alignment Engine

The Alignment Engine is responsible for precise fiber-to-chip alignment, which is critical for optical packaging. It includes:

- Coarse alignment using machine vision
- Fine alignment using optical power feedback
- Hybrid algorithms combining global search and local optimization
- Real-time monitoring and adjustment

### Process Control System

The Process Control System manages manufacturing workflows, job scheduling, and process monitoring:

- Definition and execution of process workflows
- Dependency management between process steps
- Error handling and recovery
- Process tracking and reporting

### BOM and Inventory Management

The BOM and Inventory Management system handles:

- Bill of Materials management
- Component tracking
- Inventory control
- Vendor integration

## API Reference

The REST API provides programmatic access to platform functionality:

### Alignment API

#### POST /api/alignment/align

Start a new alignment operation.

**Request Body:**
```json
{
  "device_id": "string",
  "parameters": {
    "positionToleranceUm": 0.1,
    "angleToleranceDeg": 0.05,
    "opticalPowerThreshold": -3.0,
    "maxIterations": 100,
    "useMachineLearning": true
  },
  "process_id": "string",
  "batch_id": "string",
  "metadata": {}
}
```

**Response:**
```json
{
  "request_id": "string",
  "status": "scheduled",
  "process_id": "string",
  "message": "Alignment operation scheduled"
}
```

#### GET /api/alignment/status/{request_id}

Get status of an alignment operation.

**Response:**
```json
{
  "request_id": "string",
  "device_id": "string",
  "success": true,
  "optical_power_dbm": -2.3,
  "position": {
    "x": 0.023,
    "y": -0.015,
    "z": 0.005
  },
  "duration_ms": 1250,
  "timestamp": "2025-05-15T14:30:45.123Z",
  "process_id": "string",
  "error": null
}
```

## User Guides

### Getting Started

1. **Installation**

   Clone the repository and install dependencies:

   ```bash
   git clone https://github.com/openmanufacturing/optical-packaging-platform.git
   cd optical-packaging-platform
   
   # Install Python dependencies with Poetry
   poetry install
   
   # Build C++ components
   mkdir build && cd build
   cmake ..
   make
   
   # Build Tauri UI
   cd src/ui
   npm install
   npm run tauri build
   ```

2. **Configuration**

   Configure the platform by editing `config.toml`:

   ```toml
   [database]
   uri = "postgresql://user:password@localhost/openmfg"
   
   [hardware]
   motion_controller_type = "aerotech"
   motion_controller_port = "/dev/ttyUSB0"
   
   [vision]
   camera_id = "Basler-acA1600-20gc"
   calibration_file = "config/vision_calibration.json"
   ```

3. **Starting the Platform**

   Start the platform:

   ```bash
   poetry run python -m openmanufacturing.main
   ```

### Workflow Creation

1. Define process templates using the UI or JSON configuration
2. Configure steps, dependencies, and parameters
3. Set validation rules for quality control
4. Save and version control process templates

### Alignment Process

1. Place device in fixture
2. Select device in UI
3. Configure alignment parameters
4. Start alignment process
5. Monitor real-time optical power
6. Review results and adjust as needed

## Deployment Guide

### Docker Deployment

The platform can be deployed using Docker:

```bash
docker-compose up -d
```

This starts:
- API server
- Tauri UI (via X11 forwarding)
- PostgreSQL database
- Redis for caching
- Monitoring stack (Prometheus, Grafana)

### Production Configuration

For production deployments:

1. Configure TLS certificates
2. Set up authentication
3. Configure backup strategy
4. Set up monitoring and alerting
5. Implement high availability if needed

## Contributing

We welcome contributions to the OpenManufacturing platform. Please see the [Contributing Guide](../CONTRIBUTING.md) for details on:

- Code of conduct
- Development workflow
- Coding standards
- Testing requirements
- Documentation standards
```

## Project Setup and Configuration

### 1. Docker Configuration (`Dockerfile` and `docker-compose.yml`)

```dockerfile
# Dockerfile
FROM ubuntu:22.04 as cpp-builder

WORKDIR /app

# Install build dependencies
RUN apt-get update && apt-get install -y \
    build-essential \
    cmake \
    g++ \
    git \
    libboost-dev \
    libboost-system-dev \
    libboost-filesystem-dev \
    libboost-program-options-dev \
    libboost-thread-dev \
    libssl-dev \
    pkg-config \
    && rm -rf /var/lib/apt/lists/*

# Copy C++ source files
COPY src/cpp /app/src/cpp
COPY CMakeLists.txt /app/

# Build C++ components
RUN mkdir -p /app/build && \
    cd /app/build && \
    cmake .. && \
    make -j$(nproc)

# Python application image
FROM python:3.11-slim

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \
    libpq-dev \
    && rm -rf /var/lib/apt/lists/*

# Copy built C++ libraries from the cpp-builder stage
COPY --from=cpp-builder /app/build/lib /app/lib

# Install Poetry
RUN pip install poetry==1.4.2

# Copy Python dependencies
COPY pyproject.toml poetry.lock* /app/

# Configure Poetry to install to system site-packages
RUN poetry config virtualenvs.create false \
    && poetry install --no-dev --no-interaction --no-ansi

# Copy application code
COPY . /app/

# Set Python path to include installed libraries
ENV PYTHONPATH=/app
ENV LD_LIBRARY_PATH=/app/lib:$LD_LIBRARY_PATH

# Run the API server
CMD ["uvicorn", "openmanufacturing.api.main:app", "--host", "0.0.0.0", "--port", "8000"]
```

```yaml
# docker-compose.yml
version: '3.8'

services:
  api:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://postgres:postgres@db:5432/openmfg
      - REDIS_URL=redis://redis:6379/0
      - LOG_LEVEL=info
    depends_on:
      - db
      - redis
    volumes:
      - ./config:/app/config
    restart: unless-stopped

  db:
    image: postgres:14
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
      - POSTGRES_DB=openmfg
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    restart: unless-stopped

  redis:
    image: redis:7
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    restart: unless-stopped

  prometheus:
    image: prom/prometheus:v2.40.0
    ports:
      - "9090:9090"
    volumes:
      - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus
    restart: unless-stopped

  grafana:
    image: grafana/grafana:9.3.2
    ports:
      - "3000:3000"
    environment:
      - GF_SECURITY_ADMIN_USER=admin
      - GF_SECURITY_ADMIN_PASSWORD=admin
    volumes:
      - ./monitoring/grafana/provisioning:/etc/grafana/provisioning
      - grafana_data:/var/lib/grafana
    depends_on:
      - prometheus
    restart: unless-stopped

volumes:
  postgres_data:
  redis_data:
  prometheus_data:
  grafana_data:
```

### 2. Python Package Configuration (`pyproject.toml`)

```toml
[tool.poetry]
name = "openmanufacturing"
version = "1.0.0"
description = "Advanced optical packaging and assembly platform for photonics manufacturing"
authors = ["OpenManufacturing Team <team@openmanufacturing.org>"]
readme = "README.md"
license = "MIT"
packages = [{include = "openmanufacturing", from = "src"}]

[tool.poetry.dependencies]
python = "^3.10"
fastapi = "^0.103.1"
uvicorn = "^0.23.2"
sqlalchemy = "^2.0.20"
alembic = "^1.12.0"
asyncpg = "^0.28.0"
pydantic = "^2.3.0"
opencv-python = "^4.8.0"
numpy = "^1.25.2"
pillow = "^10.0.0"
redis = "^5.0.0"
prometheus-client = "^0.17.1"
pyyaml = "^6.0.1"
typer = "^0.9.0"
rich = "^13.5.2"
python-multipart = "^0.0.6"
pyjwt = "^2.8.0"
cryptography = "^41.0.3"
httpx = "^0.24.1"
pandas = "^2.1.0"
matplotlib = "^3.8.0"
scikit-learn = "^1.3.0"
scipy = "^1.11.2"

[tool.poetry.group.dev.dependencies]
pytest = "^7.4.1"
pytest-asyncio = "^0.21.1"
pytest-cov = "^4.1.0"
black = "^23.7.0"
isort = "^5.12.0"
mypy = "^1.5.1"
flake8 = "^6.1.0"
pre-commit = "^3.3.3"
faker = "^19.3.1"
pytest-mock = "^3.11.1"
types-pyyaml = "^6.0.12.11"
types-redis = "^4.6.0.3"
sphinx = "^7.2.5"
sphinx-rtd-theme = "^1.3.0"
pytest-xdist = "^3.3.1"

[build-system]
requires = ["poetry-core>=1.0.0"]
build-backend = "poetry.core.masonry.api"

[tool.black]
line-length = 100
target-version = ["py310"]

[tool.isort]
profile = "black"
line_length = 100

[tool.mypy]
python_version = "3.10"
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = true
disallow_incomplete_defs = true

[tool.pytest.ini_options]
markers = [
    "slow: marks tests as slow (deselect with '-m \"not slow\"')",
    "integration: marks tests as integration tests",
    "e2e: marks tests as end-to-end tests",
]
testpaths = ["tests"]
```

### 3. CI/CD Configuration (`.github/workflows/ci.yml`)

```yaml
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  test:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:14
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: openmfg_test
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      
      redis:
        image: redis:7
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
      
      - name: Install Poetry
        uses: snok/install-poetry@v1
        with:
          version: 1.4.2
      
      - name: Install dependencies
        run: |
          poetry install
      
      - name: Install C++ dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential cmake libboost-dev libboost-system-dev libboost-filesystem-dev libboost-program-options-dev libboost-thread-dev
      
      - name: Build C++ components
        run: |
          mkdir build
          cd build
          cmake ..
          make -j$(nproc)
      
      - name: Lint with flake8
        run: |
          poetry run flake8 src tests
      
      - name: Type check with mypy
        run: |
          poetry run mypy src
      
      - name: Format check with black
        run: |
          poetry run black --check src tests
      
      - name: Import sort check with isort
        run: |
          poetry run isort --check-only src tests
      
      - name: Run tests
        run: |
          poetry run pytest tests/unit --cov=src --cov-report=xml
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/openmfg_test
          REDIS_URL: redis://localhost:6379/0
      
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage.xml
          fail_ci_if_error: true
  
  build:
    needs: test
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      
      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_TOKEN }}
      
      - name: Build and push API
        uses: docker/build-push-action@v4
        with:
          context: .
          push: true
          tags: openmanufacturing/api:latest
          cache-from: type=registry,ref=openmanufacturing/api:buildcache
          cache-to: type=registry,ref=openmanufacturing/api:buildcache,mode=max
  
  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}
      
      - name: Update deployment file
        run: |
          TAG=$(echo $GITHUB_SHA | head -c7)
          sed -i 's|openmanufacturing/api:latest|openmanufacturing/api:'"$TAG"'|' k8s/deployment.yaml
      
      - name: Save DigitalOcean kubeconfig
        run: doctl kubernetes cluster kubeconfig save ${{ secrets.CLUSTER_NAME }}
      
      - name: Deploy to k8s
        run: kubectl apply -f k8s/
      
      - name: Verify deployment
        run: kubectl rollout status deployment/openmanufacturing-api
```

## Conclusion

The OpenManufacturing platform provides a comprehensive solution for automating optical packaging and assembly processes in silicon photonics and quantum computing manufacturing. The platform combines high-performance C++ components for real-time control with a flexible Python architecture for process management and a modern Tauri UI for monitoring and control.

This modular approach allows manufacturing engineers to define, execute, and monitor complex optical packaging workflows with precision alignment capabilities, comprehensive traceability, and quality control.

The platform's key features include:

1. **Advanced Alignment Algorithms**: Multi-stage alignment combining vision-based coarse alignment and optical power-based fine alignment
2. **Comprehensive Process Management**: Workflow definition, execution, monitoring, and reporting
3. **Real-time Monitoring**: Live optical power tracking and position visualization
4. **Extensive Logging and Traceability**: Complete history of manufacturing processes and alignments
5. **Modern User Interface**: Intuitive Tauri-based desktop application
6. **Robust API**: RESTful API for integration with other systems
7. **Containerized Deployment**: Easy deployment using Docker and Kubernetes

With this platform, manufacturers can achieve higher yields, better process consistency, and reduced costs in optical packaging operations.

